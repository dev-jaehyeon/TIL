Default Fuction Arguments

-  함수가 인자를 받을 때 default로 정해둔 인자를 사용함으로서 일일이 다 정해주지 않아도 된다.
- C# 유니티에서 많이 봤던 것이다.

Inline Function

간단한 코드를 보자.

```c++
#include <iostream>	
using namespace std;

int Square(int x)
{
	return x * x;
}

int main()
{	
	int val = 5;
	int result = Square(val);
	cout << result << endl;
	return 0;
}
```

함수에는 오버헤드라는 것이 있다.

```
오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.

예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데, 안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면, 오버헤드는 5초가 된다. 또한 이 처리 B를 개선해 B'라는 처리를 한 결과, 처리시간이 12초가 되었다면, 이 경우 오버헤드가 3초 단축되었다고 말한다
```

오버헤드는 UDEMY에서 Jump라고 표현하는데, 이는 int result = Square(val); 에서 함수를 실행하기위해 함수가 정의되어 있는 곳 까지 점프한다. 함수에서 인자로 받은 값은 Stack에 할당된다. 계산 후 다시 돌아온다. 어디로 돌아와야 될지 아는 곳이다.

때때로 이런 오버헤드가 엄청나게 많다면 어떨까? 예를 들어 금융기관에서 초당 엄청나게 많은 트랜잭션이 있다면? 매크로를 사용하면 될 것이다. 근데 매크로는 디버깅이 너무 어렵다. 심지어 어떻게 사용하는지도 모르겠다.

```c++
#include <iostream>	
#define Squares(x) x*x
using namespace std;


inline int Square(int x)
{
	return x * x;
}

int main()
{	
	int val = 5;
	int result = Square(val);
	int result2 = Squares(1 + 23.3f);
	cout << result2 << endl;
	return 0;
}

```

매크로를 저렇게 사용하면 47을 출력한다... (23.3의 제곱이 47일리가 없다)

이럴 때 사용하는 것인 Inline Function이다.

아래는 기초플러스에서 공부한 내용이다: 467페이지 인라인 함수

```
컴파일 작업의 최종 산출물은 기계어 명령으로 이루어진 실행 프로그램이다. 프로그램을 실행하면 운영 체제는 이 명령들을 컴퓨터의 메모리에 로드한다. 로드된 명령들은 각각 하나의 특정 메모리 주소를 갖는다. 프로그램이 실행되고 함수를 호출 할 때 프로그램은 그 함수의 주소로 점프했다가 함수의 처리가 종결되면 원래의 자리로 돌아온다. 함수를 호출 할 때 스택에 매개변수를 복사하고 ~~~~
이렇게 오버헤드라는 것이 발생하는데, 이게 길어지면 그만큼 성능에 문제가 생기는 것이다. 이를 위해 인라인 함수를 사용한다. 인라인 함수는 컴파일된 함수코드가 프로그램의 다른 코드 안에 직접 삽입되어 있다. 이 말은 함수 호출을 함수 코드로 대체한다는 뜻이다. 다만, 일반 함수에 비해 메모리 사용 측면에서는 불리한데, 어떤 프로그램이 인라인 함수를 호출한다면, 그 프로그램은 그 함수의 사본을 프로그램의 코드 안에 열번이나 삽입해야 한다.
```

- 인라인 함수는 작은 함수에 사용하는 것이 바람직하다.